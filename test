#!/usr/bin/env bash

# Load the shared-library and name each of the functions found therein
declare -a enables=(
    hellow
    walk_opts
    walk_args
    nameref_arg
    read_array
    write_array
    identify_name
    func_callback
    demo_collections
    show_attributes
)
enable -f ./builtin.so "${enables[@]}"

# 'B' for bold, 'I' for 'italic', and 'X' to clear text attributes
# I will use these to highlight words in the text blocks.
declare B=$'\e[34;1m'
declare I=$'\e[33;1m'
declare X=$'\e[m'

####################################################################
bogus_func()
{
    local -a patharr
    local OIFS="$IFS"
    local IFS=':'
    patharr=( $PATH )
    local IFS="$OIFS"
    echo "There are ${#patharr[@]} path elements."
}

####################################################################
test_hellow()
{
    cat <<EOF
${B}
Demonstrate function hellow
===========================
${X}
This is a test of my first Bash loadable builtin.  Besides
simply printing a message to announce itself, it shows the
process ID to confirm that the custom Bash builtin is in the
save process as the caller.  This is necessary to ensure that
variables set in the C code can be read in the Bash script
upon return.

Previously, I had some tests for unexpected arguments.  I no
longer include these tests in the script after more experience
developing loadable builtins.

By the way, the process Id of this script is $$.

With no further delay, let's run function ${B}hellow${X}.

EOF
    hellow

    echo
}

####################################################################
test_walk_opts()
{
    cat <<EOF
${B}
Demonstrate builtin function 'walk_opts'
========================================
${X}
The second of my experiments explores how to parse the
arguments of a builtin function call.

Options are string arguments that have a hyphen prefix.
Normally, options may or may not include a value, but in
this early learning experiment, this we're only identifying
options used.

Calling:
${B}walk_opts${X} ${I}-a -b${X}
EOF
    walk_opts -a -b

    echo
}


####################################################################
test_walk_args()
{
    cat <<EOF
${B}
Demonstrate builtin function 'walk_args'
========================================
${X}
This third experiment simply walks arguments.  While working
on these experiments, I noticed how example code processed
options in one loop, and the processes non-option arguments
in a second loop.

Calling:
${B}walk_args${X} ${I}Jack Jill John Joan Jenny George${X}
EOF

    walk_args Jack Jill John Joan Jenny George
    echo
}

####################################################################
test_nameref()
{
    cat <<EOF
${B}
Demonstrate builtin function 'nameref_arg'
==========================================
${X}
This is where the coding gets more real, attempting to see if
a variable can be read by reference (as if by ${B}local -n ref='name'${X}.

In this test, a variable named ${B}bogus${X} will be initialized with
an identifiable phrase, ${I}Value going in${X}.  When the function
${B}nameref_arg${X} will announce the value if finds, and then will
replace the value to be announced by the script when the ${B}nameref_arg${X}
function returns.

The second argument will simply be a global environment variable to be
announced in the function.

Calling:
${B}nameref_arg${X} ${I}bogus USED${X}
EOF
    local bogus="Value going in"
    nameref_arg bogus USER

    cat <<EOF
The value of ${B}bogus${X} upon return, is ${I}$bogus${X}.
EOF
    echo
    }

####################################################################
test_read_array()
{
    cat <<EOF
${B}
Demonstrate builtin function 'read_array'
=========================================
${X}
Array variables are a very useful Bash feature that I want to
be able to access from the builtin C code.  This function is
an experiment for access to script-declared arrays.

This experiment declares and initializes an array variable,
then passes the name of the variable to a builtin function
named ${B}read_array${X}.

EOF

    local -a myarray
    myarray=( One Two Three Four Five )
    myarray+=( Six )

    local -a rearr=(
        ^
        \(              # group 1
           [^@]+        # recipient
        \)
        @               # match but don't capture
        \(              # group 2
        .\*             # sub-domain.  Prevent OS substitution with
                        # single-escaped asterisk
        \)
        \(              # group 3
           \\.          # match but don't capture.  Prevent regex wildcard
                        # match with double-escaped dot
           \(           # group 4
              [^\\.]+   # match non-dot characters, prevent regex wildcard match
           \)
        \)
        $
    )
    local OIFS="$IFS"
    local IFS=''
    local re="${rearr[*]}"
    echo "re is $re"
    IFS="$OIFS"
    unset OIFS

    local email_addr="john.doe@gamail.com"
    if [[ "$email_addr" =~  $re ]]; then
        echo "Matched"
    else
        echo "Failed to match"
    fi

    read_array "myarray" "BASH_REMATCH"
}

####################################################################
test_write_array()
{
    declare -a myarray=( One Two Three Four Five Six )
    echo "Before calling 'write_array', myarray is '${myarray[*]}'"
    write_array "myarray"
    echo "AFTER calling 'write_array', myarray is '${myarray[*]}'"
}

declare -i int_global=2
####################################################################
test_identify_name()
{
    closure_func() { echo "Hi"; }

    declare -i int_name=0
    declare -a array_name=()
    declare -A assoc_name=()
    declare unspecified_name="bogus"

    # identify_name int_global int_name array_name assoc_name unspecified_name test_write_array
    identify_name closure_func func_var
}

####################################################################
test_func_callback()
{
    nested_function()
    {
        echo "You made it to 'nested_function()'."
        echo "nested_function received $# arguments."
    }

    cat <<EOF
About to begin test of loadable/builtin function func_callback.
EOF

    func_callback "test_write_array"
    func_callback "nested_function" arg1 arg2 arg3
    func_callback "ip" "address"
}

####################################################################
test_demo_collections()
{
    local -a array=( One Two Three Four Five Six )
    local -A map=( key1 value1 key2 value2 key3 value3 )
    local -n nameref="array"

    # show_attributes "array" "map" "nameref" "enables" "test_func_callback" "func_callback"

    # demo_collections "array"
    # echo "Upon return, array has ${#array[*]} elements.  They are:"
    # local fname
    # for fname in "${array[@]}"; do
    #     echo "   $fname"
    # done

    demo_collections "map"
    # demo_collections "nameref"
}

# test_hellow
# read -n1 -p Press\ a\ key\ to\ continue
# test_walk_opts
# test_walk_args
# test_nameref
# test_read_array
# test_write_array
# test_identify_name
# test_func_callback
test_demo_collections
