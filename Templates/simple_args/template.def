// -*- mode:c -*-

#include <bash/builtins.h>
#ifndef EXECUTION_FAILURE
#include <bash/shell.h>
#endif

// Create access to an otherwise unavailable function
// that executes script functions:
extern int execute_command PARAMS((COMMAND *));

#include <stdio.h>
#include <stdarg.h>
static const char *error_name = "TEMPLATE_ERR";
static const char *value_name = "TEMPLATE_VAL";

/**
 * @brief Report error details to a shell var for script use.
 *
 * Leaving the error message in a shell variable permits
 * detailed and specific error information and the ability
 * of a script to decide whether and how to respond to an
 * error.
 * 
 */
int printf_to_shell_var(const char *format, ...)
{
   va_list list_args;
   va_start(list_args, format);

   int ccount = vsnprintf(NULL, 0, format, list_args);
   va_end(list_args);

   if (ccount>0)
   {
      ++ccount;

      char *buff = (char*)xmalloc(ccount);
      if (buff)
      {
         va_start(list_args, format);
         vsnprintf(buff, ccount, format, list_args);
         va_end(list_args);

         bind_variable(error_name, buff, 0);

         xfree(buff);
      }
   }

   return ccount;
}

/**
 * @brief Call to clear TEMPLATE_ERROR if it's in use
 */
void drain_error_sink(void)
{
   SHELL_VAR *sv = find_variable(error_name);
   if (sv)
      unbind_variable(error_name);
}

/**
 * @brief Clear TEMPLATE_VAL before each call
 */
void clear_result_value(void)
{
   SHELL_VAR *sv = find_variable(value_name);
   if (sv)
      unbind_variable(value_name);
}

/*
 * Uncomment only one of the following for error reporting.
 * Use 'printf_to_shell_var' to put error message in a variable,
 * otherwise use 'printf' to immediately print error messages:
 *
 * On formatting error messages:
 *   - Don't include a trailing newline if you are using
 *     'printf_to_shell_var' because the script should decide
 *     how the error output will be formatted.
 */
int (*ERROR_SINK)(const char *format, ...) = printf_to_shell_var;
// int (*ERROR_SINK)(const char *format, ...) = printf;

#include <argeater.h>
#include <alloca.h>

static const char *help_flag = NULL;
static const char *errmsg = NULL;

AE_ITEM actions[] = {
   { &help_flag, "help", 'h', AET_FLAG_OPTION,
     "Show usage instructions", NULL,
     argeater_string_setter },

   { &value_name, "value", 'v', AET_VALUE_OPTION,
     "Change value name", NULL,
     argeater_string_setter },

   { &errmsg, "error message", 'e', AET_VALUE_OPTION,
     "Set fake error message" }
};

void show_usage(AE_MAP *map)
{
   argeater_show_usage(map,"TEMPLATE");
   argeater_show_options(map, 3);
   argeater_show_arguments(map, 3);
}


static int TEMPLATE_builtin(WORD_LIST *list)
{
   int  retval = EXECUTION_FAILURE;
   drain_error_sink();
   clear_result_value();

   help_flag = NULL;
   errmsg = NULL;

   ACLONE *clones = CLONE_WORD_LIST(list);
   AE_MAP map = INIT_MAP(actions);

   if (argeater_process(clones, &map))
   {
      if (help_flag)
      {
         show_usage(&map);
         retval = EXECUTION_SUCCESS;
         goto early_exit;
      }

      if (errmsg)
      {
         (*ERROR_SINK)("Contrived error message is '%s'", errmsg);
         goto early_exit;
      }

      bind_variable(value_name, "Hello from Bash builtin.", 0);

      retval = EXECUTION_SUCCESS;
   }

  early_exit:
   return retval;
}

static char *desc_TEMPLATE[] = {
   "TEMPLATE - My Bash builtin",
   "",
   "Use Bash builtin 'TEMPLATE' to do cool stuff.",
   (char *)NULL
};

struct builtin TEMPLATE_struct = {
   .name      = "TEMPLATE",
   .function  = TEMPLATE_builtin,
   .flags     = BUILTIN_ENABLED,
   .long_doc  = desc_TEMPLATE,
   .short_doc = "TEMPLATE [arguments]",
   .handle    = 0
};


// Setup for compiling in Emacs:

/* Local Variables:                 */
/* compile-command: "gcc           \*/
/*    -std=c99 -Wall -Werror -ggdb \*/
/*    -fPIC --shared               \*/
/*    -I /usr/include/bash/include \*/
/*    -o TEMPLATE TEMPLATE.c       \*/
/*    -largeater"                   */
/* End:                             */

